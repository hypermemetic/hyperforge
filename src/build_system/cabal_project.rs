//! Cabal project file generator (UNIFY-6)
//!
//! Generates/merges workspace-level cabal.project listing all
//! directories with .cabal files.

use std::path::Path;

/// Report from cabal project generation
#[derive(Debug, Clone)]
pub struct CabalProjectReport {
    pub packages: Vec<String>,
    pub content: String,
    pub action: FileAction,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum FileAction {
    Created,
    Updated,
    Unchanged,
}

/// Information about a Haskell package in the workspace
#[derive(Debug, Clone)]
pub struct CabalPackageInfo {
    pub name: String,
    pub path: String, // relative to workspace root
}

/// Generate a cabal.project file from detected Haskell packages.
pub fn generate_cabal_project(
    workspace_root: &Path,
    packages: &[CabalPackageInfo],
    dry_run: bool,
) -> Result<CabalProjectReport, String> {
    if packages.is_empty() {
        return Err("No Haskell packages found in workspace".to_string());
    }

    let mut pkg_paths: Vec<String> = packages.iter().map(|p| p.path.clone()).collect();
    pkg_paths.sort();

    // Generate cabal.project content
    let mut content = String::new();
    content.push_str("-- Generated by hyperforge workspace unify\n");
    content.push_str("-- Do not edit manually; re-run `workspace unify` to regenerate.\n\n");
    content.push_str("packages:\n");
    for pkg in &pkg_paths {
        content.push_str(&format!("  {}/\n", pkg));
    }

    let project_path = workspace_root.join("cabal.project");

    let action = if !dry_run {
        if project_path.exists() {
            let existing = std::fs::read_to_string(&project_path).unwrap_or_default();
            if existing == content {
                FileAction::Unchanged
            } else {
                std::fs::write(&project_path, &content)
                    .map_err(|e| format!("Failed to write cabal.project: {}", e))?;
                FileAction::Updated
            }
        } else {
            std::fs::write(&project_path, &content)
                .map_err(|e| format!("Failed to write cabal.project: {}", e))?;
            FileAction::Created
        }
    } else if project_path.exists() {
        let existing = std::fs::read_to_string(&project_path).unwrap_or_default();
        if existing == content {
            FileAction::Unchanged
        } else {
            FileAction::Updated
        }
    } else {
        FileAction::Created
    };

    Ok(CabalProjectReport {
        packages: pkg_paths,
        content,
        action,
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_cabal_project() {
        let tmp = tempfile::TempDir::new().unwrap();
        let packages = vec![
            CabalPackageInfo {
                name: "synapse".to_string(),
                path: "synapse".to_string(),
            },
            CabalPackageInfo {
                name: "plexus-protocol".to_string(),
                path: "plexus-protocol".to_string(),
            },
        ];

        let report = generate_cabal_project(tmp.path(), &packages, true).unwrap();
        assert_eq!(
            report.packages,
            vec!["plexus-protocol", "synapse"]
        );
        assert!(report.content.contains("packages:"));
        assert!(report.content.contains("  plexus-protocol/"));
        assert!(report.content.contains("  synapse/"));
        assert_eq!(report.action, FileAction::Created);
    }
}
