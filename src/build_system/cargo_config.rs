//! Cargo config generator (replaces workspace Cargo.toml)
//!
//! Generates `.cargo/config.toml` with `[patch.crates-io]` entries so that
//! sibling crates resolve locally during development. Each repo keeps its
//! own lockfile and feature resolution â€” no shared Cargo workspace.

use std::path::Path;

use super::DepRef;

/// Report from cargo config generation
#[derive(Debug, Clone)]
pub struct CargoConfigReport {
    pub patches: Vec<(String, String)>, // (crate_name, path)
    pub content: String,
    pub action: FileAction,
    pub cleanup: Vec<(String, FileAction)>, // (relative description, action taken)
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum FileAction {
    Created,
    Updated,
    Unchanged,
    Removed,
}

/// Information about a Rust crate in the workspace
#[derive(Debug, Clone)]
pub struct CrateInfo {
    pub name: String,
    pub version: String,
    pub path: String, // relative to workspace root
    pub dependencies: Vec<DepRef>,
}

/// Generate `.cargo/config.toml` with `[patch.crates-io]` from detected Rust crates.
///
/// Scans `crates` for sibling dependencies referenced via crates.io (not path deps)
/// and writes patch entries so Cargo resolves them locally. After writing, cleans up
/// any old workspace `Cargo.toml` + `Cargo.lock` artifacts and ensures `.cargo/` is
/// in `.gitignore`.
pub fn generate_cargo_config(
    workspace_root: &Path,
    crates: &[CrateInfo],
    dry_run: bool,
) -> Result<CargoConfigReport, String> {
    if crates.is_empty() {
        return Err("No Rust crates found in workspace".to_string());
    }

    // Build patch section: for each crate in the workspace that is referenced
    // by another workspace crate via crates.io (not path), add a patch entry
    let crate_names: std::collections::HashSet<&str> =
        crates.iter().map(|c| c.name.as_str()).collect();

    let mut patches: Vec<(String, String)> = Vec::new();
    let mut patch_names = std::collections::HashSet::new();

    for krate in crates {
        for dep in &krate.dependencies {
            if crate_names.contains(dep.name.as_str()) && !dep.is_path_dep {
                if patch_names.insert(dep.name.clone()) {
                    if let Some(target) = crates.iter().find(|c| c.name == dep.name) {
                        patches.push((dep.name.clone(), target.path.clone()));
                    }
                }
            }
        }
    }
    patches.sort_by(|a, b| a.0.cmp(&b.0));

    // Build the [patch.crates-io] content, merging into existing config if present
    let config_dir = workspace_root.join(".cargo");
    let config_path = config_dir.join("config.toml");

    let mut doc = if config_path.exists() {
        let existing = std::fs::read_to_string(&config_path)
            .map_err(|e| format!("Failed to read .cargo/config.toml: {}", e))?;
        existing
            .parse::<toml_edit::DocumentMut>()
            .map_err(|e| format!("Failed to parse .cargo/config.toml: {}", e))?
    } else {
        let mut d = toml_edit::DocumentMut::new();
        d.decor_mut()
            .set_prefix("# Generated by hyperforge workspace unify\n# Do not edit manually; re-run `workspace unify` to regenerate.\n\n");
        d
    };

    // Build the patch.crates-io table
    if patches.is_empty() {
        // Remove patch section if it exists and there are no patches
        doc.remove("patch");
    } else {
        let mut crates_io_table = toml_edit::Table::new();
        for (name, path) in &patches {
            let mut dep_table = toml_edit::InlineTable::new();
            dep_table.insert("path", toml_edit::Value::from(path.as_str()));
            crates_io_table.insert(name, toml_edit::value(dep_table));
        }
        let mut patch_table = toml_edit::Table::new();
        patch_table.insert("crates-io", toml_edit::Item::Table(crates_io_table));
        doc.insert("patch", toml_edit::Item::Table(patch_table));
    }

    let content = doc.to_string();

    // Determine action for .cargo/config.toml
    let action = if !dry_run {
        std::fs::create_dir_all(&config_dir)
            .map_err(|e| format!("Failed to create .cargo/ directory: {}", e))?;

        if config_path.exists() {
            let existing = std::fs::read_to_string(&config_path).unwrap_or_default();
            if existing == content {
                FileAction::Unchanged
            } else {
                std::fs::write(&config_path, &content)
                    .map_err(|e| format!("Failed to write .cargo/config.toml: {}", e))?;
                FileAction::Updated
            }
        } else {
            std::fs::write(&config_path, &content)
                .map_err(|e| format!("Failed to write .cargo/config.toml: {}", e))?;
            FileAction::Created
        }
    } else if config_path.exists() {
        let existing = std::fs::read_to_string(&config_path).unwrap_or_default();
        if existing == content {
            FileAction::Unchanged
        } else {
            FileAction::Updated
        }
    } else {
        FileAction::Created
    };

    // Cleanup old workspace artifacts
    let mut cleanup = Vec::new();

    let old_cargo_toml = workspace_root.join("Cargo.toml");
    if old_cargo_toml.exists() {
        if let Ok(contents) = std::fs::read_to_string(&old_cargo_toml) {
            if let Ok(parsed) = contents.parse::<toml_edit::DocumentMut>() {
                // Only remove if it's a workspace Cargo.toml (has [workspace] with members)
                if let Some(ws) = parsed.get("workspace") {
                    if ws.get("members").is_some() {
                        if !dry_run {
                            let _ = std::fs::remove_file(&old_cargo_toml);
                        }
                        cleanup.push(("Cargo.toml (workspace)".to_string(), FileAction::Removed));
                    }
                }
            }
        }
    }

    let old_cargo_lock = workspace_root.join("Cargo.lock");
    // Remove Cargo.lock if we removed the workspace Cargo.toml
    if old_cargo_lock.exists() && cleanup.iter().any(|(d, _)| d.contains("Cargo.toml")) {
        if !dry_run {
            let _ = std::fs::remove_file(&old_cargo_lock);
        }
        cleanup.push(("Cargo.lock (workspace)".to_string(), FileAction::Removed));
    }

    // Ensure .cargo/ is in .gitignore
    ensure_gitignore(workspace_root, dry_run, &mut cleanup);

    Ok(CargoConfigReport {
        patches,
        content,
        action,
        cleanup,
    })
}

/// Ensure `.cargo/` is listed in the root `.gitignore`.
fn ensure_gitignore(
    workspace_root: &Path,
    dry_run: bool,
    cleanup: &mut Vec<(String, FileAction)>,
) {
    let gitignore_path = workspace_root.join(".gitignore");
    let cargo_dir_pattern = ".cargo/";

    if gitignore_path.exists() {
        if let Ok(contents) = std::fs::read_to_string(&gitignore_path) {
            let already_ignored = contents.lines().any(|line| {
                let trimmed = line.trim();
                trimmed == cargo_dir_pattern || trimmed == ".cargo"
            });
            if !already_ignored {
                if !dry_run {
                    let new_contents = if contents.ends_with('\n') {
                        format!("{}{}\n", contents, cargo_dir_pattern)
                    } else {
                        format!("{}\n{}\n", contents, cargo_dir_pattern)
                    };
                    let _ = std::fs::write(&gitignore_path, new_contents);
                }
                cleanup.push((".gitignore (added .cargo/)".to_string(), FileAction::Updated));
            }
        }
    } else {
        if !dry_run {
            let _ = std::fs::write(&gitignore_path, format!("{}\n", cargo_dir_pattern));
        }
        cleanup.push((".gitignore (created with .cargo/)".to_string(), FileAction::Created));
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_config_basic() {
        let tmp = tempfile::TempDir::new().unwrap();
        let crates = vec![
            CrateInfo {
                name: "crate-a".to_string(),
                version: "0.1.0".to_string(),
                path: "crate-a".to_string(),
                dependencies: vec![],
            },
            CrateInfo {
                name: "crate-b".to_string(),
                version: "0.2.0".to_string(),
                path: "crate-b".to_string(),
                dependencies: vec![DepRef {
                    name: "crate-a".to_string(),
                    version_req: Some("0.1.0".to_string()),
                    is_path_dep: false,
                    path: None,
                }],
            },
        ];

        let report = generate_cargo_config(tmp.path(), &crates, true).unwrap();
        assert_eq!(report.patches.len(), 1);
        assert_eq!(report.patches[0], ("crate-a".to_string(), "crate-a".to_string()));
        assert!(report.content.contains("[patch.crates-io]"));
        // Should NOT contain [workspace]
        assert!(!report.content.contains("[workspace]"));
    }

    #[test]
    fn test_generate_config_no_patches_for_path_deps() {
        let tmp = tempfile::TempDir::new().unwrap();
        let crates = vec![
            CrateInfo {
                name: "crate-a".to_string(),
                version: "0.1.0".to_string(),
                path: "crate-a".to_string(),
                dependencies: vec![],
            },
            CrateInfo {
                name: "crate-b".to_string(),
                version: "0.2.0".to_string(),
                path: "crate-b".to_string(),
                dependencies: vec![DepRef {
                    name: "crate-a".to_string(),
                    version_req: Some("0.1.0".to_string()),
                    is_path_dep: true,
                    path: Some("../crate-a".to_string()),
                }],
            },
        ];

        let report = generate_cargo_config(tmp.path(), &crates, true).unwrap();
        assert!(report.patches.is_empty());
        assert!(!report.content.contains("[patch.crates-io]"));
    }

    #[test]
    fn test_generate_config_writes_file() {
        let tmp = tempfile::TempDir::new().unwrap();
        let crates = vec![
            CrateInfo {
                name: "crate-a".to_string(),
                version: "0.1.0".to_string(),
                path: "crate-a".to_string(),
                dependencies: vec![],
            },
            CrateInfo {
                name: "crate-b".to_string(),
                version: "0.2.0".to_string(),
                path: "crate-b".to_string(),
                dependencies: vec![DepRef {
                    name: "crate-a".to_string(),
                    version_req: Some("0.1.0".to_string()),
                    is_path_dep: false,
                    path: None,
                }],
            },
        ];

        let report = generate_cargo_config(tmp.path(), &crates, false).unwrap();
        assert_eq!(report.action, FileAction::Created);

        let config_path = tmp.path().join(".cargo/config.toml");
        assert!(config_path.exists());
        let written = std::fs::read_to_string(config_path).unwrap();
        assert!(written.contains("[patch.crates-io]"));
        assert!(written.contains("crate-a"));
    }

    #[test]
    fn test_generate_config_removes_old_workspace() {
        let tmp = tempfile::TempDir::new().unwrap();

        // Create an old workspace Cargo.toml
        std::fs::write(
            tmp.path().join("Cargo.toml"),
            "[workspace]\nresolver = \"2\"\nmembers = [\"crate-a\"]\n",
        )
        .unwrap();
        // Create an old Cargo.lock
        std::fs::write(tmp.path().join("Cargo.lock"), "# dummy lock").unwrap();

        let crates = vec![CrateInfo {
            name: "crate-a".to_string(),
            version: "0.1.0".to_string(),
            path: "crate-a".to_string(),
            dependencies: vec![],
        }];

        let report = generate_cargo_config(tmp.path(), &crates, false).unwrap();

        // Old workspace files should be removed
        assert!(!tmp.path().join("Cargo.toml").exists());
        assert!(!tmp.path().join("Cargo.lock").exists());
        assert_eq!(report.cleanup.len(), 3); // Cargo.toml, Cargo.lock, .gitignore
        assert!(report.cleanup.iter().any(|(d, a)| d.contains("Cargo.toml") && *a == FileAction::Removed));
        assert!(report.cleanup.iter().any(|(d, a)| d.contains("Cargo.lock") && *a == FileAction::Removed));
    }

    #[test]
    fn test_generate_config_preserves_existing_sections() {
        let tmp = tempfile::TempDir::new().unwrap();
        let cargo_dir = tmp.path().join(".cargo");
        std::fs::create_dir_all(&cargo_dir).unwrap();
        std::fs::write(
            cargo_dir.join("config.toml"),
            "[build]\njobs = 4\n",
        )
        .unwrap();

        let crates = vec![
            CrateInfo {
                name: "crate-a".to_string(),
                version: "0.1.0".to_string(),
                path: "crate-a".to_string(),
                dependencies: vec![],
            },
            CrateInfo {
                name: "crate-b".to_string(),
                version: "0.2.0".to_string(),
                path: "crate-b".to_string(),
                dependencies: vec![DepRef {
                    name: "crate-a".to_string(),
                    version_req: Some("0.1.0".to_string()),
                    is_path_dep: false,
                    path: None,
                }],
            },
        ];

        let report = generate_cargo_config(tmp.path(), &crates, false).unwrap();
        // Should preserve [build] section
        assert!(report.content.contains("[build]"));
        assert!(report.content.contains("jobs = 4"));
        // And also have patches
        assert!(report.content.contains("[patch.crates-io]"));
    }

    #[test]
    fn test_gitignore_created() {
        let tmp = tempfile::TempDir::new().unwrap();
        let crates = vec![CrateInfo {
            name: "crate-a".to_string(),
            version: "0.1.0".to_string(),
            path: "crate-a".to_string(),
            dependencies: vec![],
        }];

        let report = generate_cargo_config(tmp.path(), &crates, false).unwrap();
        let gitignore = std::fs::read_to_string(tmp.path().join(".gitignore")).unwrap();
        assert!(gitignore.contains(".cargo/"));
        assert!(report.cleanup.iter().any(|(d, _)| d.contains(".gitignore")));
    }

    #[test]
    fn test_gitignore_appended() {
        let tmp = tempfile::TempDir::new().unwrap();
        std::fs::write(tmp.path().join(".gitignore"), "target/\n").unwrap();

        let crates = vec![CrateInfo {
            name: "crate-a".to_string(),
            version: "0.1.0".to_string(),
            path: "crate-a".to_string(),
            dependencies: vec![],
        }];

        let _ = generate_cargo_config(tmp.path(), &crates, false).unwrap();
        let gitignore = std::fs::read_to_string(tmp.path().join(".gitignore")).unwrap();
        assert!(gitignore.contains("target/"));
        assert!(gitignore.contains(".cargo/"));
    }

    #[test]
    fn test_gitignore_not_duplicated() {
        let tmp = tempfile::TempDir::new().unwrap();
        std::fs::write(tmp.path().join(".gitignore"), "target/\n.cargo/\n").unwrap();

        let crates = vec![CrateInfo {
            name: "crate-a".to_string(),
            version: "0.1.0".to_string(),
            path: "crate-a".to_string(),
            dependencies: vec![],
        }];

        let report = generate_cargo_config(tmp.path(), &crates, false).unwrap();
        // Should not report gitignore changes since .cargo/ is already there
        assert!(!report.cleanup.iter().any(|(d, _)| d.contains(".gitignore")));
    }
}
